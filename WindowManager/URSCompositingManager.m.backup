//
//  URSCompositingManager.m
//  uroswm - XRender Compositing Manager
//
//  Implementation of XRender-based compositing with comprehensive error handling.
//  Falls back gracefully to non-compositing mode on any errors.
//

#import "URSCompositingManager.h"
#import <XCBKit/XCBScreen.h>
#import <xcb/xcb.h>
#import <xcb/composite.h>
#import <xcb/xfixes.h>
#import <xcb/render.h>
#import <xcb/damage.h>

@interface URSCompositingManager ()

@property (strong, nonatomic) XCBConnection *connection;
@property (assign, nonatomic) xcb_window_t overlayWindow;
@property (assign, nonatomic) xcb_render_picture_t rootPicture;
@property (assign, nonatomic) xcb_render_picture_t overlayPicture;
@property (strong, nonatomic) NSMutableDictionary *windowPictures;
@property (strong, nonatomic) NSMutableSet *compositedWindows;

@property (assign, nonatomic) BOOL compositingEnabled;
@property (assign, nonatomic) BOOL compositingActive;
@property (assign, nonatomic) BOOL extensionsAvailable;

// Extension version tracking
@property (assign, nonatomic) uint8_t compositeOpcode;
@property (assign, nonatomic) uint8_t renderOpcode;
@property (assign, nonatomic) uint8_t damageEventBase;
@property (assign, nonatomic) uint8_t fixesOpcode;

// Throttling to prevent excessive recomposites
@property (assign, nonatomic) NSTimeInterval lastCompositeTime;
@property (assign, nonatomic) BOOL compositeScheduled;

@end

@implementation URSCompositingManager

+ (instancetype)sharedManager {
    static URSCompositingManager *sharedManager = nil;
    @synchronized(self) {
        if (!sharedManager) {
            sharedManager = [[URSCompositingManager alloc] init];
        }
    }
    return sharedManager;
}

- (instancetype)init {
    self = [super init];
    if (self) {
        _compositingEnabled = NO;
        _compositingActive = NO;
        _extensionsAvailable = NO;
        _overlayWindow = XCB_NONE;
        _lastCompositeTime = 0;
        _compositeScheduled = NO;
        _rootPicture = XCB_NONE;
        _overlayPicture = XCB_NONE;
        _windowPictures = [[NSMutableDictionary alloc] init];
        _compositedWindows = [[NSMutableSet alloc] init];
    }
    return self;
}

#pragma mark - Initialization

- (BOOL)initializeWithConnection:(XCBConnection *)connection {
    if (!connection) {
        NSLog(@"[CompositingManager] ERROR: No connection provided");
        return NO;
    }
    
    self.connection = connection;
    NSLog(@"[CompositingManager] Checking for required X extensions...");
    
    // Check for required extensions with defensive error handling
    if (![self checkExtensions]) {
        NSLog(@"[CompositingManager] Required extensions not available");
        NSLog(@"[CompositingManager] Falling back to non-compositing mode");
        return NO;
    }
    
    self.extensionsAvailable = YES;
    self.compositingEnabled = YES;
    NSLog(@"[CompositingManager] Initialization successful - compositing available");
    return YES;
}

- (BOOL)checkExtensions {
    @try {
        xcb_connection_t *conn = [self.connection connection];
        BOOL allExtensionsOK = YES;
        
        // Check COMPOSITE extension
        const xcb_query_extension_reply_t *composite_ext = 
            xcb_get_extension_data(conn, &xcb_composite_id);
        
        if (!composite_ext || !composite_ext->present) {
            NSLog(@"[CompositingManager] COMPOSITE extension not available");
            allExtensionsOK = NO;
        } else {
            self.compositeOpcode = composite_ext->major_opcode;
            
            // Query version
            xcb_composite_query_version_cookie_t version_cookie = 
                xcb_composite_query_version(conn, 
                                           XCB_COMPOSITE_MAJOR_VERSION, 
                                           XCB_COMPOSITE_MINOR_VERSION);
            xcb_composite_query_version_reply_t *version_reply = 
                xcb_composite_query_version_reply(conn, version_cookie, NULL);
            
            if (version_reply) {
                NSLog(@"[CompositingManager] COMPOSITE v%d.%d available", 
                      version_reply->major_version, version_reply->minor_version);
                free(version_reply);
            } else {
                NSLog(@"[CompositingManager] WARNING: Could not query COMPOSITE version");
            }
        }
        
        // Check RENDER extension
        const xcb_query_extension_reply_t *render_ext = 
            xcb_get_extension_data(conn, &xcb_render_id);
        
        if (!render_ext || !render_ext->present) {
            NSLog(@"[CompositingManager] RENDER extension not available");
            allExtensionsOK = NO;
        } else {
            self.renderOpcode = render_ext->major_opcode;
            NSLog(@"[CompositingManager] RENDER extension available");
        }
        
        // Check DAMAGE extension
        const xcb_query_extension_reply_t *damage_ext = 
            xcb_get_extension_data(conn, &xcb_damage_id);
        
        if (!damage_ext || !damage_ext->present) {
            NSLog(@"[CompositingManager] DAMAGE extension not available");
            allExtensionsOK = NO;
        } else {
            self.damageEventBase = damage_ext->first_event;
            NSLog(@"[CompositingManager] DAMAGE extension available (event base: %u)", 
                  self.damageEventBase);
        }
        
        // Check XFIXES extension
        const xcb_query_extension_reply_t *fixes_ext = 
            xcb_get_extension_data(conn, &xcb_xfixes_id);
        
        if (!fixes_ext || !fixes_ext->present) {
            NSLog(@"[CompositingManager] XFIXES extension not available");
            allExtensionsOK = NO;
        } else {
            self.fixesOpcode = fixes_ext->major_opcode;
            NSLog(@"[CompositingManager] XFIXES extension available");
        }
        
        return allExtensionsOK;
        
    } @catch (NSException *exception) {
        NSLog(@"[CompositingManager] EXCEPTION checking extensions: %@", exception.reason);
        return NO;
    }
}

#pragma mark - Activation

- (BOOL)activateCompositing {
    if (!self.compositingEnabled) {
        NSLog(@"[CompositingManager] Cannot activate - not initialized properly");
        return NO;
    }
    
    if (self.compositingActive) {
        NSLog(@"[CompositingManager] Compositing already active");
        return YES;
    }
    
    @try {
        NSLog(@"[CompositingManager] Activating compositing...");
        
        // Redirect all windows for compositing
        if (![self redirectWindows]) {
            NSLog(@"[CompositingManager] Failed to redirect windows");
            return NO;
        }
        
        // Create overlay window
        if (![self createOverlayWindow]) {
            NSLog(@"[CompositingManager] Failed to create overlay window");
            [self cleanup];
            return NO;
        }
        
        // Create render pictures
        if (![self createRenderPictures]) {
            NSLog(@"[CompositingManager] Failed to create render pictures");
            [self cleanup];
            return NO;
        }
        
        self.compositingActive = YES;
        NSLog(@"[CompositingManager] Compositing activated successfully");
        NSLog(@"[CompositingManager] Windows will now be composited with XRender");
        
        // Perform initial composite to make windows visible
        [self compositeScreen];
        NSLog(@"[CompositingManager] Initial composite complete");
        
        return YES;
        
    } @catch (NSException *exception) {
        NSLog(@"[CompositingManager] EXCEPTION activating compositing: %@", exception.reason);
        [self cleanup];
        return NO;
    }
}

- (BOOL)redirectWindows {
    @try {
        xcb_connection_t *conn = [self.connection connection];
        XCBScreen *screen = [[self.connection screens] firstObject];
        
        if (!screen) {
            NSLog(@"[CompositingManager] No screen available");
            return NO;
        }
        
        // Redirect all subwindows of root to offscreen storage (checked version only)
        xcb_generic_error_t *error = NULL;
        xcb_void_cookie_t cookie = xcb_composite_redirect_subwindows_checked(
            conn, [screen screen]->root, XCB_COMPOSITE_REDIRECT_MANUAL);
        error = xcb_request_check(conn, cookie);
        
        if (error) {
            NSLog(@"[CompositingManager] Error redirecting windows: %d", error->error_code);
            free(error);
            return NO;
        }
        
        [self.connection flush];
        NSLog(@"[CompositingManager] Windows redirected to offscreen buffers");
        return YES;
        
    } @catch (NSException *exception) {
        NSLog(@"[CompositingManager] EXCEPTION redirecting windows: %@", exception.reason);
        return NO;
    }
}

- (BOOL)createOverlayWindow {
    @try {
        xcb_connection_t *conn = [self.connection connection];
        XCBScreen *screen = [[self.connection screens] firstObject];
        
        if (!screen) {
            return NO;
        }
        
        // Get the composite overlay window
        xcb_composite_get_overlay_window_cookie_t overlay_cookie = 
            xcb_composite_get_overlay_window(conn, [screen screen]->root);
        xcb_composite_get_overlay_window_reply_t *overlay_reply = 
            xcb_composite_get_overlay_window_reply(conn, overlay_cookie, NULL);
        
        if (!overlay_reply) {
            NSLog(@"[CompositingManager] Failed to get overlay window");
            return NO;
        }
        
        self.overlayWindow = overlay_reply->overlay_win;
        free(overlay_reply);
        
        NSLog(@"[CompositingManager] Got overlay window: %u", self.overlayWindow);
        
        // Set the overlay window to receive no events - completely transparent to input
        uint32_t event_mask = XCB_EVENT_MASK_NO_EVENT;
        xcb_change_window_attributes(conn, self.overlayWindow, XCB_CW_EVENT_MASK, &event_mask);
        
        // Make overlay window transparent to input using XFixes
        // Create an empty region (no rectangles = fully transparent to input)
        xcb_xfixes_region_t region = xcb_generate_id(conn);
        xcb_xfixes_create_region(conn, region, 0, NULL);
        
        // Set both bounding and input shapes to empty (transparent)
        xcb_xfixes_set_window_shape_region(conn, self.overlayWindow,
                                           XCB_SHAPE_SK_INPUT, 0, 0, region);
        xcb_xfixes_set_window_shape_region(conn, self.overlayWindow,
                                           XCB_SHAPE_SK_BOUNDING, 0, 0, XCB_NONE);
        xcb_xfixes_destroy_region(conn, region);
        
        NSLog(@"[CompositingManager] Overlay window configured for input passthrough");
        
        // Map the overlay window
        xcb_map_window(conn, self.overlayWindow);
        [self.connection flush];
        
        NSLog(@"[CompositingManager] Overlay window created and mapped: %u", self.overlayWindow);
        return YES;
        
    } @catch (NSException *exception) {
        NSLog(@"[CompositingManager] EXCEPTION creating overlay: %@", exception.reason);
        return NO;
    }
}

- (BOOL)createRenderPictures {
    @try {
        xcb_connection_t *conn = [self.connection connection];
        XCBScreen *screen = [[self.connection screens] firstObject];
        
        if (!screen) {
            return NO;
        }
        
        // Find render format for the root window
        xcb_render_query_pict_formats_cookie_t formats_cookie = 
            xcb_render_query_pict_formats(conn);
        xcb_render_query_pict_formats_reply_t *formats_reply = 
            xcb_render_query_pict_formats_reply(conn, formats_cookie, NULL);
        
        if (!formats_reply) {
            NSLog(@"[CompositingManager] Failed to query render formats");
            return NO;
        }
        
        // Find format for 24-bit RGB
        xcb_render_pictformat_t format = [self findFormat:formats_reply depth:24];
        free(formats_reply);
        
        if (format == XCB_NONE) {
            NSLog(@"[CompositingManager] Could not find suitable render format");
            return NO;
        }
        
        // Create picture for root window
        self.rootPicture = xcb_generate_id(conn);
        xcb_render_create_picture(conn, self.rootPicture, 
                                 [screen screen]->root, format, 0, NULL);
        
        // Create picture for overlay window
        self.overlayPicture = xcb_generate_id(conn);
        xcb_render_create_picture(conn, self.overlayPicture, 
                                 self.overlayWindow, format, 0, NULL);
        
        [self.connection flush];
        NSLog(@"[CompositingManager] Render pictures created successfully");
        return YES;
        
    } @catch (NSException *exception) {
        NSLog(@"[CompositingManager] EXCEPTION creating pictures: %@", exception.reason);
        return NO;
    }
}

- (xcb_render_pictformat_t)findFormat:(xcb_render_query_pict_formats_reply_t *)formats 
                                depth:(uint8_t)depth {
    xcb_render_pictforminfo_iterator_t iter = 
        xcb_render_query_pict_formats_formats_iterator(formats);
    
    for (; iter.rem; xcb_render_pictforminfo_next(&iter)) {
        if (iter.data->depth == depth) {
            return iter.data->id;
        }
    }
    
    return XCB_NONE;
}

#pragma mark - Window Management

- (void)registerWindow:(xcb_window_t)window {
    if (!self.compositingActive) {
        return; // Silently ignore if compositing not active
    }
    
    @try {
        NSString *windowKey = [NSString stringWithFormat:@"%u", window];
        
        // Don't register twice
        if ([self.compositedWindows containsObject:windowKey]) {
            return;
        }
        
        [self.compositedWindows addObject:windowKey];
        
        // Create damage object for the window
        xcb_connection_t *conn = [self.connection connection];
        xcb_damage_damage_t damage = xcb_generate_id(conn);
        xcb_damage_create(conn, damage, window, XCB_DAMAGE_REPORT_LEVEL_NON_EMPTY);
        [self.connection flush]; // Ensure damage object is created
        
        NSLog(@"[CompositingManager] Registered window %u for compositing, created damage object %u", 
              window, damage);
        
    } @catch (NSException *exception) {
        NSLog(@"[CompositingManager] EXCEPTION registering window %u: %@", 
              window, exception.reason);
    }
}

- (void)unregisterWindow:(xcb_window_t)window {
    if (!self.compositingActive) {
        return;
    }
    
    @try {
        NSString *windowKey = [NSString stringWithFormat:@"%u", window];
        [self.compositedWindows removeObject:windowKey];
        
        // Remove window picture if exists
        NSNumber *pictureNum = self.windowPictures[windowKey];
        if (pictureNum) {
            xcb_render_picture_t picture = [pictureNum unsignedIntValue];
            xcb_render_free_picture([self.connection connection], picture);
            [self.windowPictures removeObjectForKey:windowKey];
        }
        
        NSLog(@"[CompositingManager] Unregistered window %u", window);
        
    } @catch (NSException *exception) {
        NSLog(@"[CompositingManager] EXCEPTION unregistering window: %@", exception.reason);
    }
}

- (void)updateWindow:(xcb_window_t)window {
    // Trigger a recomposite when a window changes
    if (self.compositingActive) {
        [self compositeScreen];
    }
}

#pragma mark - Compositing

- (void)compositeScreen {
    if (!self.compositingActive) {
        return;
    }
    
    @try {
        xcb_connection_t *conn = [self.connection connection];
        XCBScreen *screen = [[self.connection screens] firstObject];
        
        if (!screen) {
            return;
        }
        
        NSLog(@"[CompositingManager] Starting composite pass...");
        
        // Clear the overlay picture (this is what's visible on screen)
        xcb_render_color_t clear_color = {0, 0, 0, 0xFFFF}; // Opaque black background
        xcb_rectangle_t rect = {0, 0, [screen screen]->width_in_pixels, [screen screen]->height_in_pixels};
        xcb_render_fill_rectangles(conn, XCB_RENDER_PICT_OP_SRC,
                                   self.overlayPicture, clear_color, 1, &rect);
        
        // Get list of all windows in stacking order
        xcb_query_tree_cookie_t tree_cookie = xcb_query_tree(conn, [screen screen]->root);
        xcb_query_tree_reply_t *tree_reply = xcb_query_tree_reply(conn, tree_cookie, NULL);
        
        if (!tree_reply) {
            NSLog(@"[CompositingManager] Failed to query window tree");
            [self.connection flush];
            return;
        }
        
        xcb_window_t *children = xcb_query_tree_children(tree_reply);
        int num_children = xcb_query_tree_children_length(tree_reply);
        
        NSLog(@"[CompositingManager] Found %d child windows to composite", num_children);
        
        int composited_count = 0;
        // Composite each window in bottom-to-top order
        for (int i = 0; i < num_children; i++) {
            xcb_window_t win = children[i];
            
            // Skip our overlay window
            if (win == self.overlayWindow) {
                continue;
            }
            
            // Get window attributes to check if it should be composited
            xcb_get_window_attributes_cookie_t attr_cookie = xcb_get_window_attributes(conn, win);
            xcb_get_window_attributes_reply_t *attr = xcb_get_window_attributes_reply(conn, attr_cookie, NULL);
            
            if (!attr) {
                continue;
            }
            
            // Skip unmapped and override-redirect windows
            if (attr->map_state != XCB_MAP_STATE_VIEWABLE || attr->_class != XCB_WINDOW_CLASS_INPUT_OUTPUT) {
                free(attr);
                continue;
            }
            
            free(attr);
            
            // Get window geometry
            xcb_get_geometry_cookie_t geom_cookie = xcb_get_geometry(conn, win);
            xcb_get_geometry_reply_t *geom = xcb_get_geometry_reply(conn, geom_cookie, NULL);
            
            if (!geom) {
                continue;
            }
            
            NSLog(@"[CompositingManager] Compositing window %u at (%d,%d) size %dx%d", 
                  win, geom->x, geom->y, geom->width, geom->height);
            
            // Create or get picture for this window
            NSString *windowKey = [NSString stringWithFormat:@"%u", win];
            NSNumber *pictureNum = self.windowPictures[windowKey];
            xcb_render_picture_t win_picture;
            
            if (!pictureNum) {
                // Create picture for window's pixmap content
                xcb_render_pictformat_t format = [self findFormatForDepth:geom->depth];
                if (format == XCB_NONE) {
                    NSLog(@"[CompositingManager] No format found for depth %d", geom->depth);
                    free(geom);
                    continue;
                }
                
                xcb_pixmap_t pixmap = xcb_generate_id(conn);
                xcb_composite_name_window_pixmap(conn, win, pixmap);
                
                win_picture = xcb_generate_id(conn);
                xcb_render_create_picture(conn, win_picture, pixmap, format, 0, NULL);
                
                self.windowPictures[windowKey] = @(win_picture);
                
                // Free the pixmap (picture holds a reference)
                xcb_free_pixmap(conn, pixmap);
                
                NSLog(@"[CompositingManager] Created picture for window %u", win);
            } else {
                win_picture = [pictureNum unsignedIntValue];
            }
            
            // Composite window onto overlay picture at its position
            xcb_render_composite(conn,
                                XCB_RENDER_PICT_OP_OVER,  // Alpha blend
                                win_picture,               // Source
                                XCB_NONE,                  // Mask (no alpha mask)
                                self.overlayPicture,       // Destination (overlay is visible)
                                0, 0,                      // src x, y
                                0, 0,                      // mask x, y
                                geom->x, geom->y,          // dst x, y
                                geom->width, geom->height); // width, height
            
            composited_count++;
            free(geom);
        }
        
        free(tree_reply);
        [self.connection flush];
        
        NSLog(@"[CompositingManager] Composite pass complete - composited %d windows", composited_count);
        
    } @catch (NSException *exception) {
        NSLog(@"[CompositingManager] EXCEPTION compositing: %@", exception.reason);
        // Don't crash, just log the error
    }
}

- (xcb_render_pictformat_t)findFormatForDepth:(uint8_t)depth {
    xcb_connection_t *conn = [self.connection connection];
    xcb_render_query_pict_formats_cookie_t formats_cookie = xcb_render_query_pict_formats(conn);
    xcb_render_query_pict_formats_reply_t *formats_reply = 
        xcb_render_query_pict_formats_reply(conn, formats_cookie, NULL);
    
    if (!formats_reply) {
        return XCB_NONE;
    }
    
    xcb_render_pictformat_t format = [self findFormat:formats_reply depth:depth];
    free(formats_reply);
    
    return format;
}

- (void)handleDamageNotify:(xcb_window_t)window {
    // Window has been damaged, schedule recomposite
    if (self.compositingActive) {
        [self scheduleComposite];
    }
}

- (void)scheduleComposite {
    if (!self.compositingActive) {
        return;
    }
    
    // Throttle to max 30fps (33ms between updates)
    NSTimeInterval now = [[NSDate date] timeIntervalSince1970];
    NSTimeInterval timeSinceLastComposite = now - self.lastCompositeTime;
    
    if (timeSinceLastComposite >= 0.033) {
        // Enough time has passed, composite now
        [self compositeScreen];
        self.lastCompositeTime = now;
        self.compositeScheduled = NO;
    } else if (!self.compositeScheduled) {
        // Schedule a delayed composite
        self.compositeScheduled = YES;
        NSTimeInterval delay = 0.033 - timeSinceLastComposite;
        [self performSelector:@selector(performScheduledComposite) 
                   withObject:nil 
                   afterDelay:delay];
    }
}

- (void)performScheduledComposite {
    self.compositeScheduled = NO;
    if (self.compositingActive) {
        [self compositeScreen];
        self.lastCompositeTime = [[NSDate date] timeIntervalSince1970];
    }
}

- (uint8_t)damageEventBase {
    return _damageEventBase;
}

#pragma mark - Deactivation & Cleanup

- (void)deactivateCompositing {
    if (!self.compositingActive) {
        return;
    }
    
    NSLog(@"[CompositingManager] Deactivating compositing...");
    
    @try {
        xcb_connection_t *conn = [self.connection connection];
        XCBScreen *screen = [[self.connection screens] firstObject];
        
        if (screen) {
            // Unredirect windows
            xcb_composite_unredirect_subwindows(conn, [screen screen]->root,
                                               XCB_COMPOSITE_REDIRECT_MANUAL);
        }
        
        [self cleanup];
        self.compositingActive = NO;
        NSLog(@"[CompositingManager] Compositing deactivated");
        
    } @catch (NSException *exception) {
        NSLog(@"[CompositingManager] EXCEPTION deactivating: %@", exception.reason);
    }
}

- (void)cleanup {
    @try {
        xcb_connection_t *conn = [self.connection connection];
        
        // Free all window pictures
        for (NSNumber *pictureNum in [self.windowPictures allValues]) {
            xcb_render_free_picture(conn, [pictureNum unsignedIntValue]);
        }
        [self.windowPictures removeAllObjects];
        
        // Free root and overlay pictures
        if (self.rootPicture != XCB_NONE) {
            xcb_render_free_picture(conn, self.rootPicture);
            self.rootPicture = XCB_NONE;
        }
        
        if (self.overlayPicture != XCB_NONE) {
            xcb_render_free_picture(conn, self.overlayPicture);
            self.overlayPicture = XCB_NONE;
        }
        
        // Release overlay window
        if (self.overlayWindow != XCB_NONE) {
            XCBScreen *screen = [[self.connection screens] firstObject];
            if (screen) {
                xcb_composite_release_overlay_window(conn, [screen screen]->root);
            }
            self.overlayWindow = XCB_NONE;
        }
        
        [self.compositedWindows removeAllObjects];
        
        [self.connection flush];
        NSLog(@"[CompositingManager] Cleanup complete");
        
    } @catch (NSException *exception) {
        NSLog(@"[CompositingManager] EXCEPTION during cleanup: %@", exception.reason);
    }
}

- (void)dealloc {
    [self cleanup];
}

@end
